/*
 * generated by Xtext 2.25.0
 */
package game.of.life.validation

import game.of.life.lifeDsl.DieAliveUnit
import game.of.life.lifeDsl.EvolutionRules
import game.of.life.lifeDsl.Model
import game.of.life.lifeDsl.Operator
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LifeDslValidator extends AbstractLifeDslValidator {
	
	@Check
    def checkDoubleInitialGrids(Model root) {
        var glist = root.grids // lists start at position 0
        for (var i = 0; i < glist.size; i++) {
            for (var j = i + 1; j < glist.size; j++) {
                if (
                	glist.get(i).row.equals(glist.get(j).row) 
                	&& glist.get(i).column.equals(glist.get(j).column)
                ) {
                    error("Double grid", null)
                }
            }
        }
    }
	
	@Check
    def checkDieAliveUnit(EvolutionRules rules) {
            if (rules !== null) {
                switch (rules.name) {
                    case DieAliveUnit::DIE:
                    	if (
                    		rules.numberOfLiveNeighbors == 3 
                    		&& (
                    			rules.operator == Operator::L 
                    			|| rules.operator == Operator::EQ
                    		)
                    	) {
                    		error("Neighbors less than or equal to 3 not
                                allowed to die", null)
                    	}
                    case DieAliveUnit::LIVE:
                        if (rules.numberOfLiveNeighbors != 2 && rules.numberOfLiveNeighbors != 3) {
                            error("Neighbors less than 2 and more than 3 not
                                allowed to live", null)
                        }
                    case DieAliveUnit::BECOME_ALIVE:
                        if (rules.numberOfLiveNeighbors != 3) {
                            info("Maybe rewrite to live or die", null)
                        }
				}
			}
	}
	
	@Check
    def checkEvolutionRules(Model root) {
            var rlist = root.rules // lists start at position 0
            for (var i = 0; i < rlist.size; i++) {
	            for (var j = i + 1; j < rlist.size; j++) {
	                if (
	                	rlist.get(i).name.equals(rlist.get(j).name) 
	                	&& rlist.get(i).operator.equals(rlist.get(j).operator)
	                	&& rlist.get(i).numberOfLiveNeighbors.equals(rlist.get(j).numberOfLiveNeighbors)
	                ) {
	                    error("Double rule", null)
	                }
	            }
	        }
	}
}
